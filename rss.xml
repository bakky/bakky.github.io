<?xml version="1.0"?>
<rss version="2.0">
  <channel>
    <title>霸小奇的博客</title>
    <link>http://bakky.github.io</link>
    <pubDate>2013-06-19 11:38:57 +0800</pubDate>
    <item>
      <title>输入流和输出流对接</title>
      <link>http://bakky.github.io/2013/工作/stream.html</link>
      <pubDate>2013-06-18 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;基本原理：通过httpClient获取服务器端输入流InputStream,然后新建一个输出流，将输入流写入到输出流中&lt;/p&gt;

&lt;p&gt;使用场景：大量数据传输，list或数组装不下的情况&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      DefaultHttpClient client = new DefaultHttpClient();
      StringBuffer getString = new StringBuffer();
      HttpMethod method = null;
      HttpResponse response;
      JSONObject res = null;
      int start = creator.indexOf(&amp;quot;(&amp;quot;);
      int end = creator.indexOf(&amp;quot;)&amp;quot;);
      String workId = creator.substring(start+1,end);
      try {
           getString.append(applyManager.getGoldServiceApi())
                .append(&amp;quot;getUserGroupList.do?appName=hermes&amp;amp;appPassword=xxx&amp;quot;)
                .append(&amp;quot;&amp;amp;groupId=&amp;quot;).append(groupid)
                .append(&amp;quot;&amp;amp;workId=&amp;quot;).append(workId);
           //发起请求
           String url = getString.toString();
           HttpGet get = new HttpGet(url);
           sendlog.warn(&amp;quot;请求黄金策url:&amp;quot;+url);
           response = client.execute(get);
           InputStream input = response.getEntity().getContent();
           File newFile = new File(tfsPath+&amp;quot;/&amp;quot;+new Date().getTime()+&amp;quot;_&amp;quot;+groupid+&amp;quot;.txt&amp;quot;);
           OutputStream output = new FileOutputStream(newFile);
           IOUtils.copy(input, output);
           sendlog.warn(&amp;quot;从黄金策拉的数据保存路径:&amp;quot;+newFile.getPath());
           return newFile.getPath();
      } catch (Exception e) {
           log.error(&amp;quot;从黄金策拉取数据出错:&amp;quot;+getString+&amp;quot;[res:]&amp;quot;+res, e);
           return null;
      }finally{
           //释放连接
           if(method!=null)
                method.releaseConnection();
      }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将输入流写到输出流中使用了apache的IOUtils工具包，注意不要将服务端获取输入流单独提取方法，因为有个释放链接的过程，而对接的时候，连接是不能被关闭的。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>追女神日记（更新中）</title>
      <link>http://bakky.github.io/2013/生活/live.html</link>
      <pubDate>2013-06-06 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;2013-06-06&lt;/p&gt;

&lt;p&gt;鼓起勇气找女神qq聊天，很平淡的说了些，女神用女神惯有的方式中断了聊天：我要去洗洗睡了&lt;/p&gt;

&lt;p&gt;呵呵 呵呵…(悲剧了)&lt;/p&gt;

&lt;p&gt;2013-06-07&lt;/p&gt;

&lt;p&gt;继续厚着脸皮找女神聊天，刚开始聊的挺严肃的，后来直入主题：你有男朋友么？女神扭扭捏捏，我猜说没有，女神说是准的，我以为说我猜准了，就说那可以追她了。结果女神的意思是准男朋友的阶段，囧，心理很失落，但还是向她表达喜欢之情，女神说谢谢。然后我呢 迅速转变角色，以一个过来人身份告诉了些爱情中应该注意的（我特么真贱啊），女神夸我人真好，（哭），事后想起来，准的又不是真的，tnnd，看来厚脸皮神功还没练到位。。。&lt;/p&gt;

&lt;p&gt;2013-06-14&lt;/p&gt;

&lt;p&gt;中间聊了两次，每次一问一答收场，昨天女神豆瓣发了一条心情：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;不得已撒的谎越来越大，逞强显得再怎么无力也得兜住，不管怎样先熬过这阵再说。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;不知道什么意思，索性问了下，女神回答：额…&lt;/p&gt;

&lt;p&gt;以为女神会接着说的，但是没有了下文，过了一会，又扯了下其它的，女神仿佛不是很想和我说话。。。遂作罢&lt;/p&gt;

&lt;p&gt;2013-06-15&lt;/p&gt;

&lt;p&gt;女神这几天由于毕业来临 会传很多照片 总有一大帮男的在下面留言 今天不知道为什么淡然了 感觉急也急不来的 等女神过了毕业季再说吧 专心工作&lt;/p&gt;

&lt;p&gt;晚上收拾东西，看到和前任女友在一起时玩时留下来的一大堆火车票、电影票、飞机票 突然莫名的特别感伤。。。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>《effective java》笔记（更新中）</title>
      <link>http://bakky.github.io/2013/笔记/effective_java.html</link>
      <pubDate>2013-05-12 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;第21条：用函数对象表示策略&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;java没有函数指针，可以用对象引用实现同样的功能&lt;/li&gt;
&lt;li&gt;如果一个类仅仅导出一个方法，那么这个实例就等同于一个指向该方法的指针（例如常见的排序比较器使用：Comparator）这样就可以在某一个对象的方法中执行其它对象。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Arrays.sort(stringArray,new Comparator&amp;lt;String&amp;gt;(){
     public int compare(String s1,String s2){
          return s1.length()-s2.length();
     }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每个比较器就是一个具体策略类，具体策略类往往使用匿名类声明（例如上面的例子），我们也可以声明一个普通的类实现Comparator接口。这个时候，我们可以考虑，因为用匿名类的话，每次执行调用的时候会生成一个新的对象实例，将这个函数对象存储在一个私有的静态final域中。&lt;/p&gt;

&lt;p&gt;如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class A{
     private static class Strlen implements Comparator&amp;lt;String&amp;gt;{
         public int compare(String s1,String s2){
          return s1.length()-s2.length();
          } 
     }
     public static final Comparator&amp;lt;String&amp;gt; STRING_LEN_COMPARE = new Strlen();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用就变成这样了：Arrays.sorts(stringArray,A.STRING_LEN_COMPARE),这样做的好处是：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;减少频繁创建对象的开销&lt;/li&gt;
&lt;li&gt;代码的可读性增加，重复利用，可以将A取一个有意义的域名称&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    <item>
      <title>《重构》笔记（更新中）</title>
      <link>http://bakky.github.io/2013/笔记/restruct.html</link>
      <pubDate>2013-05-08 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;第1章：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在设计前期采用模式常常导致过度工程&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;开发业务代码时很容易面向过程编程&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;大方法差成小方法:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;所有行为拆成很多小行为，然后将合适的行为提炼到对象中
分拆出小方法（要避免过多参数的传递）
这样做可能还会带来代码量的增加
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;运用常用设计模式
    可以穿插看设计模式的书籍（对应设计模式）&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;第2章&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;设计模式更像是重构的一种手段&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;重构就是在整理代码，让代码容易被理解喝修改&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;第6章&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;优秀的代码组织和性能间的权衡&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    <item>
      <title>String和StringUtil的判断为空区别</title>
      <link>http://bakky.github.io/2012/工作/empty.html</link>
      <pubDate>2012-08-29 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;1.&lt;code&gt;str.isEmpty();return str==null||str.length()==0&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;str为null,则抛出空指针异常&lt;/p&gt;

&lt;p&gt;2.&lt;code&gt;StringUtils.isEmpty(str)&lt;/code&gt;返回true的条件是&lt;code&gt;str==null&lt;/code&gt; 或 &lt;code&gt;str.length()==0&lt;/code&gt;    null安全&lt;/p&gt;

&lt;p&gt;3.&lt;code&gt;StringUtils.isBlank(str)&lt;/code&gt;返回true的条件是&lt;code&gt;str==null&lt;/code&gt; 或 &lt;code&gt;str.length()==0&lt;/code&gt; 或 由空白符(whitespace) 构成&lt;/p&gt;

&lt;p&gt;4.&lt;code&gt;StringUtils.trimToNull(str)&lt;/code&gt;、&lt;code&gt;StringUtils.trimToEmpty(str)&lt;/code&gt;  去掉字符串两端的控制符(control characters, char &amp;lt;= 32) ,如果变为 null 或&amp;rdquo;&amp;ldquo;，则返回 null、&amp;rdquo;&amp;rdquo;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>map的遍历和排序</title>
      <link>http://bakky.github.io/2012/工作/map.html</link>
      <pubDate>2012-08-10 12:00:00 +0800</pubDate>
      <description>&lt;h3&gt;map的遍历&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;最常规的一种遍历方法：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;public static void work(Map&amp;lt;String, Student&amp;gt; map) {
    Collection&amp;lt;Student&amp;gt; c = map.values();
    Iterator it = c.iterator();
    for (; it.hasNext();) {
        System.out.println(it.next());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;利用keyset进行遍历，它的优点在于可以根据你所想要的key值得到你想要的 values，更具灵活性！！&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;public static void workByKeySet(Map&amp;lt;String, Student&amp;gt; map) {
    Set&amp;lt;String&amp;gt; key = map.keySet();
    for (Iterator it = key.iterator(); it.hasNext();) {
        String s = (String) it.next();
        System.out.println(map.get(s));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;比较复杂的一种遍历，它的灵活性太强了，想得到什么就能得到什么&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;public static void workByEntry(Map&amp;lt;String, Student&amp;gt; map) {
    Set&amp;lt;Map.Entry&amp;lt;String, Student&amp;gt;&amp;gt; set = map.entrySet();
    for (Iterator&amp;lt;Map.Entry&amp;lt;String, Student&amp;gt;&amp;gt; it = set.iterator(); it.hasNext();) {
        Map.Entry&amp;lt;String, Student&amp;gt; entry = (Map.Entry&amp;lt;String, Student&amp;gt;) it.next();
        System.out.println(entry.getKey() + &amp;quot;---&amp;gt;&amp;quot; + entry.getValue());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;map中的value排序&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;中心思想：对key按value进行排序，然后放入linkedHashMap中,按要求定制Comparator&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;List&amp;lt;Long&amp;gt; keys = new ArrayList&amp;lt;Long&amp;gt;(map.keySet());           
Collections. sort(keys,new Comparator&amp;lt;Object &amp;gt;(){
    @Override
    public int compare( Object arg0, Object arg1) {
        return map.get(arg0).compareTo(map.get(arg1));
    }                
});    
Map&amp;lt;Long, String&amp;gt; catmap = new LinkedHashMap&amp;lt;Long,String&amp;gt;();  for(Long l : keys){           
    catmap.put(l, map.get(l));       
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
  </channel>
</rss>