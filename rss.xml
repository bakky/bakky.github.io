<?xml version="1.0"?>
<rss version="2.0">
  <channel>
    <title>霸小奇的博客</title>
    <link>http://bakky.github.io</link>
    <pubDate>2013-06-23 12:05:22 +0800</pubDate>
    <item>
      <title>输入流和输出流对接</title>
      <link>http://bakky.github.io/2013/工作/stream.html</link>
      <pubDate>2013-06-18 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;br /&gt;
基本原理：通过httpClient获取服务器端输入流InputStream,然后新建一个输出流，将输入流写入到输出流中&lt;/p&gt;

&lt;p&gt;使用场景：大量数据传输，list或数组装不下的情况&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      DefaultHttpClient client = new DefaultHttpClient();
      StringBuffer getString = new StringBuffer();
      HttpMethod method = null;
      HttpResponse response;
      JSONObject res = null;
      int start = creator.indexOf(&amp;quot;(&amp;quot;);
      int end = creator.indexOf(&amp;quot;)&amp;quot;);
      String workId = creator.substring(start+1,end);
      try {
           getString.append(applyManager.getGoldServiceApi())
                .append(&amp;quot;getUserGroupList.do?appName=hermes&amp;amp;appPassword=xxx&amp;quot;)
                .append(&amp;quot;&amp;amp;groupId=&amp;quot;).append(groupid)
                .append(&amp;quot;&amp;amp;workId=&amp;quot;).append(workId);
           //发起请求
           String url = getString.toString();
           HttpGet get = new HttpGet(url);
           sendlog.warn(&amp;quot;请求黄金策url:&amp;quot;+url);
           response = client.execute(get);
           InputStream input = response.getEntity().getContent();
           File newFile = new File(tfsPath+&amp;quot;/&amp;quot;+new Date().getTime()+&amp;quot;_&amp;quot;+groupid+&amp;quot;.txt&amp;quot;);
           OutputStream output = new FileOutputStream(newFile);
           IOUtils.copy(input, output);
           sendlog.warn(&amp;quot;从黄金策拉的数据保存路径:&amp;quot;+newFile.getPath());
           return newFile.getPath();
      } catch (Exception e) {
           log.error(&amp;quot;从黄金策拉取数据出错:&amp;quot;+getString+&amp;quot;[res:]&amp;quot;+res, e);
           return null;
      }finally{
           //释放连接
           if(method!=null)
                method.releaseConnection();
      }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将输入流写到输出流中使用了apache的IOUtils工具包，注意不要将服务端获取输入流单独提取方法，因为有个释放链接的过程，而对接的时候，连接是不能被关闭的。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>追女神日记（更新中）</title>
      <link>http://bakky.github.io/2013/生活/live.html</link>
      <pubDate>2013-06-06 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;2013-06-06&lt;/p&gt;

&lt;p&gt;鼓起勇气找女神qq聊天，很平淡的说了些，女神用女神惯有的方式中断了聊天：我要去洗洗睡了&lt;/p&gt;

&lt;p&gt;呵呵 呵呵…(悲剧了)&lt;/p&gt;

&lt;p&gt;2013-06-07&lt;/p&gt;

&lt;p&gt;继续厚着脸皮找女神聊天，刚开始聊的挺严肃的，后来直入主题：你有男朋友么？女神扭扭捏捏，我猜说没有，女神说是准的，我以为说我猜准了，就说那可以追她了。结果女神的意思是准男朋友的阶段，囧，心理很失落，但还是向她表达喜欢之情，女神说谢谢。然后我呢 迅速转变角色，以一个过来人身份告诉了些爱情中应该注意的（我特么真贱啊），女神夸我人真好，（哭），事后想起来，准的又不是真的，tnnd，看来厚脸皮神功还没练到位。。。&lt;/p&gt;

&lt;p&gt;2013-06-14&lt;/p&gt;

&lt;p&gt;中间聊了两次，每次一问一答收场，昨天女神豆瓣发了一条心情：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;不得已撒的谎越来越大，逞强显得再怎么无力也得兜住，不管怎样先熬过这阵再说。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;不知道什么意思，索性问了下，女神回答：额…&lt;/p&gt;

&lt;p&gt;以为女神会接着说的，但是没有了下文，过了一会，又扯了下其它的，女神仿佛不是很想和我说话。。。遂作罢&lt;/p&gt;

&lt;p&gt;2013-06-15&lt;/p&gt;

&lt;p&gt;女神这几天由于毕业来临 会传很多照片 总有一大帮男的在下面留言 今天不知道为什么淡然了 感觉急也急不来的 等女神过了毕业季再说吧 专心工作&lt;/p&gt;

&lt;p&gt;晚上收拾东西，看到和前任女友在一起时玩时留下来的一大堆火车票、电影票、飞机票 突然莫名的特别感伤。。。&lt;/p&gt;

&lt;p&gt;2013-06-23&lt;/p&gt;

&lt;p&gt;半夜，女神在线，又去聊她，说了两句后，女神又以“下了 我去洗洗睡了”结束了&lt;/p&gt;

&lt;p&gt;呵呵。。。呵呵。。。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>《effective java》笔记（更新中）</title>
      <link>http://bakky.github.io/2013/笔记/effective_java.html</link>
      <pubDate>2013-05-12 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4&gt;第21条：用函数对象表示策略&lt;/h4&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;java没有函数指针，可以用对象引用实现同样的功能&lt;/li&gt;
&lt;li&gt;如果一个类仅仅导出一个方法，那么这个实例就等同于一个指向该方法的指针（例如常见的排序比较器使用：Comparator）这样就可以在某一个对象的方法中执行其它对象。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Arrays.sort(stringArray,new Comparator&amp;lt;String&amp;gt;(){
     public int compare(String s1,String s2){
          return s1.length()-s2.length();
     }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每个比较器就是一个具体策略类，具体策略类往往使用匿名类声明（例如上面的例子），我们也可以声明一个普通的类实现Comparator接口。这个时候，我们可以考虑，因为用匿名类的话，每次执行调用的时候会生成一个新的对象实例，将这个函数对象存储在一个私有的静态final域中。&lt;/p&gt;

&lt;p&gt;如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class A{
     private static class Strlen implements Comparator&amp;lt;String&amp;gt;{
         public int compare(String s1,String s2){
          return s1.length()-s2.length();
          } 
     }
     public static final Comparator&amp;lt;String&amp;gt; STRING_LEN_COMPARE = new Strlen();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用就变成这样了：Arrays.sorts(stringArray,A.STRING_LEN_COMPARE),这样做的好处是：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;减少频繁创建对象的开销&lt;/li&gt;
&lt;li&gt;代码的可读性增加，重复利用，可以将A取一个有意义的域名称&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    <item>
      <title>《重构》笔记（更新中）</title>
      <link>http://bakky.github.io/2013/笔记/restruct.html</link>
      <pubDate>2013-05-08 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4&gt;第1章&lt;/h4&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在设计前期采用模式常常导致过度工程&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;开发业务代码时很容易面向过程编程&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;大方法差成小方法:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;所有行为拆成很多小行为，然后将合适的行为提炼到对象中
分拆出小方法（要避免过多参数的传递）
这样做可能还会带来代码量的增加
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;运用常用设计模式
    可以穿插看设计模式的书籍（对应设计模式）&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;第2章&lt;/h4&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;设计模式更像是重构的一种手段&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;重构就是在整理代码，让代码容易被理解喝修改&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;第6章&lt;/h4&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;优秀的代码组织和性能间的权衡&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    <item>
      <title>btrace用法补充</title>
      <link>http://bakky.github.io/2012/工作/btrace.html</link>
      <pubDate>2012-10-25 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;下载btrace并安装，将bin目录加入到path路径下
/builder 文件夹下为类文件 ，最好反编译下，因为写脚本的过程中只能用里面提供的api&lt;/p&gt;

&lt;p&gt;/samples 文件夹下为一些例子，各种标签和属性的用法可以用来参考&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://kenai.com/projects/btrace/pages/UserGuide&#34;&gt;btrace user guide&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;自己写了个统计在一段时间内方法执行时间的脚本：&lt;/p&gt;

&lt;p&gt;运行类：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import java. util. Random;
public class CaseObject {
      private static int sleepTotalTime= 0;    
      public boolean execute(int sleepTime) throws Exception {
          System. out. println( &amp;quot;sleep: &amp;quot;+sleepTime );
          sleepTotalTime+=sleepTime ;
          Thread. sleep(sleepTime );
          return true ;
      }
      public static void main(String [] args ) throws Exception {
           Random random =new Random();
           CaseObject object =new CaseObject();
           boolean result=true ;
           while(result ){
              result= object. execute( random. nextInt( 1000));
              Thread. sleep(1000 );
           }
     }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;btrace脚本：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import static com. sun. btrace. BTraceUtils.println ;
import static com. sun. btrace. BTraceUtils.str ;
import static com. sun. btrace. BTraceUtils.strcat ;
import static com. sun. btrace. BTraceUtils.timeMillis ;
import java. util. concurrent. atomic. AtomicInteger;
import com. sun. btrace. BTraceUtils;
import com. sun. btrace. annotations.BTrace ;
import com. sun. btrace. annotations.Kind ;
import com. sun. btrace. annotations.Location ;
import com. sun. btrace. annotations.OnMethod ;
import com. sun. btrace. annotations.OnTimer ;
import com. sun. btrace. annotations.Return ;
import com. sun. btrace. annotations.Self ;
import com. sun. btrace. annotations.TLS;
@BTrace
public class TraceMethodArgsAndReturn {
     private static Long total_time = 0L;
     private static AtomicInteger ato = BTraceUtils.newAtomicInteger (0 );    
     @TLS static long beginTime;
       @OnMethod(
          clazz= &amp;quot;CaseObject&amp;quot;,
          method= &amp;quot;execute&amp;quot;
       )
       public static void traceExecuteBegin(){
          beginTime=timeMillis ();
       }     
       @OnMethod(
          clazz= &amp;quot;CaseObject&amp;quot;,
          method= &amp;quot;execute&amp;quot;,
          location= @Location( Kind. RETURN)
       )
       public static void traceExecute(@Self CaseObject object,int sleepTime , @Return boolean result){
             println( strcat(&amp;quot;sleepTime is:&amp;quot; ,str(sleepTime)));
             BTraceUtils.getAndIncrement (ato);
             println( strcat(&amp;quot;第&amp;quot; ,strcat(str( BTraceUtils.get (ato)),&amp;quot;次执行&amp;quot;)));
             total_time += timeMillis()-beginTime ;
             println( strcat(strcat (&amp;quot;此次执行时间是:&amp;quot; ,str(timeMillis()- beginTime)),&amp;quot;ms&amp;quot; ));
     }   
       @OnTimer( 4000)
       public static void print(){
             println( strcat(&amp;quot;总共耗时：&amp;quot; ,str(total_time)));
             println( strcat(&amp;quot;总共执行&amp;quot; ,strcat(str( BTraceUtils.get (ato)),&amp;quot;次&amp;quot;)));
             float average = total_time.floatValue ()/BTraceUtils .get(ato);
             println( strcat(&amp;quot;平均执行时间:&amp;quot; ,str(average)));
       }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;记住，btrace脚本中只能用btrace提供的api，可能会有些不适应，所以需要反编译类文件查看用法。&lt;/p&gt;

&lt;p&gt;@TLS：标记为静态属性且为thread local&lt;/p&gt;
</description>
    </item>
    <item>
      <title>定义一种返回结果</title>
      <link>http://bakky.github.io/2012/工作/result.html</link>
      <pubDate>2012-10-11 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Result &amp;lt;T&amp;gt; {
     private boolean isSuccess ;
     private String message;
     private T result ;     
     /**
      * 创建一个只包含结果的result
      * @param isSuccess
      */
     public Result( boolean isSuccess){
            this.setSuccess (isSuccess );
     }     
     /**
      * 创建一个不带返回对象的result
      * @param isSuccess
      * @param message
      */
     public Result( boolean isSuccess, String message) {
            this.isSuccess = isSuccess;
            this.message = message;
     }     
     /**
      * 创建一个带返回对象的result
      * @param isSuccess
      * @param message
      */
     public Result( boolean isSuccess, String message, T result ) {
            this.isSuccess = isSuccess;
            this.message = message;
            this.result = result;
     }     
     /**
      * 返回一个成功的result，包含要返回的对象
      * @param result 结果对象
      */
     public Result( T result ){
            this.isSuccess =true;
            this.setResult (result );
     }
     /**
      * 创建一个失败的result，不包含返回对象
      * @param msg
      * @return
      */
     public static Result &amp;lt;Boolean &amp;gt; fail( String msg ){
            return new Result &amp;lt;Boolean &amp;gt;(false, msg);
     }   
     /**
      * 创建一个成功的result，不包含返回对象
      * @param msg
      * @return
      */
     public static Result &amp;lt;Boolean &amp;gt; succeed( String msg ){
            return new Result &amp;lt;Boolean &amp;gt;(true, msg);
     }     
     /**
      * 创建一个成功的result，不包含返回对象
      * @return
      */
     public static Result &amp;lt;Boolean &amp;gt; succeed(){
            return new Result &amp;lt;Boolean &amp;gt;(true);
     }     
     public boolean isSuccess () {
            return isSuccess ;
     }
     public Result&amp;lt; T&amp;gt; setSuccess(boolean isSuccess) {
            this.isSuccess = isSuccess;
            return this ;
     }
     public boolean isFailed (){
            return !isSuccess;
     }
     public String getMessage() {
            return message ;
     }
     public Result&amp;lt; T&amp;gt; setMessage(String message) {
            this.message = message;
            return this ;
     }
     public T getResult() {
            return result ;
     }
     public Result&amp;lt; T&amp;gt; setResult(T result) {
            this.result = result;
            return this ;
     }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    <item>
      <title>异常</title>
      <link>http://bakky.github.io/2012/工作/exception.html</link>
      <pubDate>2012-09-13 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;异常都派生于Throwable类的一个实例。&lt;/li&gt;
&lt;li&gt;Throwable下有两个子类分支：Error和Exception&lt;/li&gt;
&lt;li&gt;Error类描述java运行时系统的内部错误和资源耗尽，这种情况很少出现&lt;/li&gt;
&lt;li&gt;Exception下面又派生出两种异常分支：通常有程序导致的错误为RuntimeException，还有一类是IOException&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;java可以声明已检查异常，告诉编译器可能会发生什么样的错误。例如读文件方法可以&lt;code&gt;throw FileNotFoundException&lt;/code&gt;异常。已检查异常可以抛出多个。&lt;/p&gt;

&lt;p&gt;我们可以自定义一个派生于Exception或其子类的类&lt;/p&gt;

&lt;p&gt;再次抛出异常或异常链：&lt;/p&gt;

&lt;p&gt;这个可能大家在调用一些通用的模块的时候会发现它的异常信息是被包装了一层的，我们需要调用
对象的&lt;code&gt;getCause()&lt;/code&gt;方法才能得到异常信息。&lt;/p&gt;

&lt;p&gt;因为每个子系统可能会产生同样的异常，当我们的上层系统捕捉到这种异常时我们并不知道是哪个底层子系统抛出的。这个时候我们就可以将原是一场捕获后重新进行包装然后抛出代表这个子系统的异常，但是原始的异常信息也不会丢失。如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;try{
   access db
}catch(SQLException e){
   Throwable se = new MyAppException(&amp;quot;db error&amp;quot;);
    se.initCause(e);
    throw se;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    <item>
      <title>velocity渲染相关</title>
      <link>http://bakky.github.io/2012/工作/velocity.html</link>
      <pubDate>2012-09-12 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4&gt;velocity中对象field的渲染&lt;/h4&gt;

&lt;p&gt;&lt;br /&gt;
没看源码，但经过实验得知：&lt;/p&gt;

&lt;p&gt;如:&lt;code&gt;$!xxx.name&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;引擎渲染的时候先去调用xxx对象的&lt;code&gt;getName()&lt;/code&gt;方法，如果有这个方法，就直接返回&lt;code&gt;getName()&lt;/code&gt;的结果，
如果没有的话就回去调用xxx对象的&lt;code&gt;get(&amp;quot;name&amp;quot;)&lt;/code&gt;方法。&lt;/p&gt;

&lt;h4&gt;velocity判断为空和null&lt;/h4&gt;

&lt;p&gt;&lt;br /&gt;
&lt;code&gt;$!item.name.isNull()&lt;/code&gt;    是否为null&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$!item.name.isNotNull()&lt;/code&gt;  是否不为null&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;code&gt;#if(!$!item.name)&lt;/code&gt;    如果不为空&lt;/p&gt;

&lt;p&gt;&lt;code&gt;#if($!item.name)&lt;/code&gt;     如果为空&lt;/p&gt;
</description>
    </item>
    <item>
      <title>代理、动态代理</title>
      <link>http://bakky.github.io/2012/工作/proxy.html</link>
      <pubDate>2012-09-08 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;br /&gt;
代理很容易理解，我们平时想要去买火车票，票贩子和代售点都可以理解为代理。
代理的结构图也很简单，代理类中含有真实类的引用，客户端调用代理类的方法，实际上代理类会去调用真实类的真实方法。那么代理类的主要作用是什么呢？就是在执行真实类的真实方法时，额外做些事情。
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;那么动态代理呢，试想我们买火车票、买飞机票用代理了，如果我们想要买国外奶粉，我们可以用代购，那么这个时候我们又要创建一个代理，如果有很多这种情况而且我们额外要做的事情差不多，那么创建很多代理类就浪费了，动态代理就是解决这种情况的，允许运行时指定其为实现任意一种接口实现类的代理类。&lt;/p&gt;

&lt;p&gt;简单示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 *买票接口
 *
 */
 pubic interface Ticket{
    public void buyTicket();
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt; /**
 *真实买火车票类
 *
 */
 public class TrainTicket implements Ticket{
    @override
    public void buyTicket(){
        System.out.println(&amp;quot;买火车票&amp;quot;);
    }
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt; /**
 *真实买飞机票类
 *
 */
  public class PlainTicket implements Ticket{
    @override
    public void buyTicket(){
        System.out.println(&amp;quot;买飞机票&amp;quot;);
    }
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt; /**
 * 代理类
 *
 */
 public class TicketProxy implements InvocationHandler{
    private Object object=null;
    public TicketProxy(Object o){
        this.object = o;
    }   
    @override
    public Object invoke(Object arg0, Method arg1, Object[] arg2){
        Object result = null;
        try{
            System.out.println(&amp;quot;我是票贩子，买票一律收20元手续费&amp;quot;);
            result = arg1.invoke(object , arg2);
            System.out.println(&amp;quot;挣钱了，买酒喝去。。。&amp;quot;);
        }catch(Exception ex){
            System.exit(1);
        }
        return result;
    }
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt; public class Client{
    public static void main(String[] args){
        Ticket t = new PlainTicket();
        Ticket proxy = Proxy.newProxyInstance(t.getClass().getClassLoader() , t.getClass().getInterfaces() , new TicketProxy(t));
        proxy.buyTicket();
    }
 } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当需要增加买奶粉的时候，我们就不需要再增加一个代理类了，而只是需要创建相关买奶粉的接口，然后增加不同的实现类。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>String和StringUtil的判断为空区别</title>
      <link>http://bakky.github.io/2012/工作/empty.html</link>
      <pubDate>2012-08-29 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;br /&gt;
1.&lt;code&gt;str.isEmpty();return str==null||str.length()==0&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;str为null,则抛出空指针异常&lt;/p&gt;

&lt;p&gt;2.&lt;code&gt;StringUtils.isEmpty(str)&lt;/code&gt;返回true的条件是&lt;code&gt;str==null&lt;/code&gt; 或 &lt;code&gt;str.length()==0&lt;/code&gt;    null安全&lt;/p&gt;

&lt;p&gt;3.&lt;code&gt;StringUtils.isBlank(str)&lt;/code&gt;返回true的条件是&lt;code&gt;str==null&lt;/code&gt; 或 &lt;code&gt;str.length()==0&lt;/code&gt; 或 由空白符(whitespace) 构成&lt;/p&gt;

&lt;p&gt;4.&lt;code&gt;StringUtils.trimToNull(str)&lt;/code&gt;、&lt;code&gt;StringUtils.trimToEmpty(str)&lt;/code&gt;  去掉字符串两端的控制符(control characters, char &amp;lt;= 32) ,如果变为 null 或&amp;rdquo;&amp;ldquo;，则返回 null、&amp;rdquo;&amp;rdquo;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>java自动装箱和拆箱</title>
      <link>http://bakky.github.io/2012/工作/box.html</link>
      <pubDate>2012-08-23 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;br /&gt;
如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;arrayList&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;Integer&amp;gt;();
list.add(3);    //1     自动打包（autowrapping）    
int n = list.get(i)  //2   拆包
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;步骤1，相当于list.add(new Integer(3))&lt;br /&gt;
步骤2，相当于nt n = list.get(i).intValue();&lt;/p&gt;

&lt;p&gt;对于封装类型的==比较 需要注意：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Integer a =100;
Integer b = 100;           
Integer c = 1000;
Integer d = 1000;           
int m = 1000;
int n = 1000;        
System. out.println(a==b);
System. out.println(c==d);           
System. out.println(m==n);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如上，返回结果分别为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;true
false
true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为什么会出现这样的结果呢？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;自动打包规范要求boolean、byte、char&amp;lt;=127,介于-128~127之间的short和int被包装到固定的对象中去&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;看源码，拿Integer举例:&lt;/p&gt;

&lt;p&gt;平常我们使用&lt;code&gt;Integer a = xxx；&lt;/code&gt;的时候，Integer类实际上是调用的是&lt;code&gt;public static Integer valueOf(int i)&lt;/code&gt;方法。这个方法是这样的:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static Integer valueOf(int i){
     final int offset = 128;
     if(i&amp;gt;= -128 &amp;amp;&amp;amp; i&amp;lt;= 127){
          return IntegerCache.cache[i+offset];
     }
     return new Integer(i); 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;IntegerCache.class:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static final Integer cache[] = new Integer[-(-128)+127+1];
static {
     for(int i=0;i&amp;lt;cache.length;i++){
          cache[i] = new Integer(i - 128);
     }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也就是说，当赋值在[-128, 127]区间时，Java是从同一个数据中取出同一个对象，即内存地址一样.可能[-128, 127]区间比较常用，这个区间内的Integer对象也作为静态变量初始化完成，这样直接返回对象可以提高效率。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>数组的trimToSize方法</title>
      <link>http://bakky.github.io/2012/工作/shuzu.html</link>
      <pubDate>2012-08-23 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;br /&gt;
- 一旦能确认数组列表的大小不再发生变化，就可以调用&lt;code&gt;trimToSize&lt;/code&gt;方法。这个方
法将存储区域的大小调整为当前元素数量所需要的是存储空间数目。垃圾回收器将回收多余的存储空间。
- 一旦整理了数组列表的大小，添加新元素就需要花时间再次移动存储块，所以应该确认不会添加任何元素时，再调用&lt;code&gt;trimToSize&lt;/code&gt;.
- 代码洁癖的人适用&lt;/p&gt;
</description>
    </item>
    <item>
      <title>map的遍历和排序</title>
      <link>http://bakky.github.io/2012/工作/map.html</link>
      <pubDate>2012-08-10 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3&gt;map的遍历&lt;/h3&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;最常规的一种遍历方法：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;public static void work(Map&amp;lt;String, Student&amp;gt; map) {
    Collection&amp;lt;Student&amp;gt; c = map.values();
    Iterator it = c.iterator();
    for (; it.hasNext();) {
        System.out.println(it.next());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;利用keyset进行遍历，它的优点在于可以根据你所想要的key值得到你想要的 values，更具灵活性！！&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;public static void workByKeySet(Map&amp;lt;String, Student&amp;gt; map) {
    Set&amp;lt;String&amp;gt; key = map.keySet();
    for (Iterator it = key.iterator(); it.hasNext();) {
        String s = (String) it.next();
        System.out.println(map.get(s));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;比较复杂的一种遍历，它的灵活性太强了，想得到什么就能得到什么&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;public static void workByEntry(Map&amp;lt;String, Student&amp;gt; map) {
    Set&amp;lt;Map.Entry&amp;lt;String, Student&amp;gt;&amp;gt; set = map.entrySet();
    for (Iterator&amp;lt;Map.Entry&amp;lt;String, Student&amp;gt;&amp;gt; it = set.iterator(); it.hasNext();) {
        Map.Entry&amp;lt;String, Student&amp;gt; entry = (Map.Entry&amp;lt;String, Student&amp;gt;) it.next();
        System.out.println(entry.getKey() + &amp;quot;---&amp;gt;&amp;quot; + entry.getValue());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;map中的value排序&lt;/h3&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;中心思想：对key按value进行排序，然后放入linkedHashMap中,按要求定制Comparator&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;List&amp;lt;Long&amp;gt; keys = new ArrayList&amp;lt;Long&amp;gt;(map.keySet());           
Collections. sort(keys,new Comparator&amp;lt;Object &amp;gt;(){
    @Override
    public int compare( Object arg0, Object arg1) {
        return map.get(arg0).compareTo(map.get(arg1));
    }                
});    
Map&amp;lt;Long, String&amp;gt; catmap = new LinkedHashMap&amp;lt;Long,String&amp;gt;();  for(Long l : keys){           
    catmap.put(l, map.get(l));       
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
  </channel>
</rss>