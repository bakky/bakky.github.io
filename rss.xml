<?xml version="1.0"?>
<rss version="2.0">
  <channel>
    <title>霸小奇的博客</title>
    <link>http://bakky.github.io</link>
    <pubDate>2013-08-14 11:03:26 +0800</pubDate>
    <item>
      <title>对象排序</title>
      <link>http://bakky.github.io/2013/工作/sort.html</link>
      <pubDate>2013-07-27 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;提起java对象排序，大家首先会想到的是&lt;code&gt;Comparator&lt;/code&gt;和&lt;code&gt;Comparable&lt;/code&gt;,在《Thinking in Java》中是这样说明二者的区别的：&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Comparable 是一个对象本身就已经支持自比较所需要实现的接口（如 String、Integer 自己就可以完成比较大小操作）&lt;/li&gt;
&lt;li&gt;Comparator 是一个专用的比较器，当这个对象不支持自比较或者自比较函数不能满足你的要求时，你可以写一个比较器来完成两个对象之间大小的比较。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;想象这么一个场景，商品对象&lt;code&gt;Item&lt;/code&gt;有价格、销量、评分等属性，不同的业务需要根据不同的属性排序，大部分是根据商品销量排序，那么如何用这个排序比较器呢？&lt;/p&gt;

&lt;p&gt;很容易想到，让商品这个类实现&lt;code&gt;Comparable&lt;/code&gt;接口，在&lt;code&gt;compareTo&lt;/code&gt;方法中比较商品销量，那么对于按销量排序的时候，只需要简单的利用&lt;code&gt;Collections.sort(itemList)&lt;/code&gt;就可以达到效果,对于其它字段的排序，我们可以在需要的时候利用匿名类的方式，简化代码，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Collections.sort(itemList, new Comparator&amp;lt;Item&amp;gt;() {
    @Override
    public int compare(Item o1, Item o2) {
        return o2.getPrice()-o1.getPrice();
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是呢，这样每次用到比较器的时候都要写一遍，而且会创建一个新的实例，对于有代码洁癖的人来说这样是不行的，于是乎，尝试将每种比较器生成一个类，这个类只有一个&lt;code&gt;Compare()&lt;/code&gt;方法，每次新增一个比较字段的时候就增加一个类，这样也可以解决问题，但是好像也不太优雅，于是进一步改进，将这些排序比较器对象存储到一个私有的静态&lt;code&gt;final&lt;/code&gt;域，然后在宿主类中导出共有的静态域，这样既可以做到重用，而且也优雅，每次增加一种比较器的时候，在宿主类中增加一个静态域即可。如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class SortComparator {
    public static final Comparator&amp;lt;Item&amp;gt; ITEM_PRICE_COMPARATOR = new ItemPriceComparator();   //按销量排序 
    public static final Comparator&amp;lt;Item&amp;gt; ITEM_SCORE_COMPARATOR = new ItemScoreComparator();   //按评分排序
    private static class ItemPriceComparator implements Comparator&amp;lt;Item&amp;gt; {
        @Override
        public int compare(Item item1, Item item2) {
            return item2.getPrice()-item1.getPrice();
        }
    }
    private static class ItemScoreComparator implements Comparator&amp;lt;Item&amp;gt; {
        @Override
        public int compare(Item item1, Item item2) {
            return (item2.getItemScore()-item1.getItemScore());
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    <item>
      <title>泛型相关知识整理</title>
      <link>http://bakky.github.io/2013/工作/generic.html</link>
      <pubDate>2013-07-17 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;h4&gt;why generic programming?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;代码重用&lt;/li&gt;
&lt;li&gt;类型安全，编译时期发现错误&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;h4&gt;what is generic programming?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;泛型分为泛型类和泛型方法。&lt;/li&gt;
&lt;li&gt;泛型处理几乎全在编译器中进行，Java编译器通过Code sharing方式为每个泛型类型创建唯一的字节码表示，并且将该泛型类型的实例都映射到这个唯一的字节码表示上。这就是通过擦除实现的&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;h4&gt;why type erasue?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;将泛型类型实例关联到同一份字节码上。&lt;/li&gt;
&lt;li&gt;编译器只为泛型类型生成一份字节码，并将其实例关联到这份字节码上。&lt;/li&gt;
&lt;li&gt;避免浪费空间&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;h4&gt;what is the type erasue?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;简单的理解为将泛型java代码转换为普通java代码，只不过编译器更直接点，将泛型java代码直接转换成普通java字节码。&lt;/li&gt;
&lt;li&gt;类型擦除的主要过程如下：

&lt;ol&gt;
&lt;li&gt;将所有的泛型参数用其最左边界（最顶级的父类型）类型替换。&lt;/li&gt;
&lt;li&gt;移除所有的类型参数。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;对于泛型编译器还做了适当优化，会在编译期间对于插除后带来的问题尽可能的处理，例如通过桥接，插入相关字节码，保证正常执行，在进行翻译泛型变量的时候自动插入强制转换字节码&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;h4&gt;what&amp;rsquo;s the problems of erasue brings?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Q1.用同一泛型类的实例区分方法签名？——NO！&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;import java.util.*;    
   public class Erasure{   
       public void test(List&amp;lt;String&amp;gt; ls){  
           System.out.println(&amp;quot;Sting&amp;quot;);  
       }  
       public void test(List&amp;lt;Integer&amp;gt; li){  
           System.out.println(&amp;quot;Integer&amp;quot;);  
       }  
  }  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译该类，参数类型明明不一样啊，一个&lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;，一个是&lt;code&gt;List&amp;lt;Integer&amp;gt;&lt;/code&gt;，但是，偷偷的说，type erasure之后，它就都是List了⋯⋯&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Q2.同时catch同一个泛型异常类的多个实例？——NO！&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;同理，如果定义了一个泛型一场类&lt;code&gt;GenericException&amp;lt;T&amp;gt;&lt;/code&gt;，千万别同时&lt;code&gt;catch GenericException&amp;lt;Integer&amp;gt;&lt;/code&gt;和&lt;code&gt;GenericException&amp;lt;String&amp;gt;&lt;/code&gt;，因为他们是一样一样滴⋯⋯&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Q3.泛型类的静态变量是共享的？——Yes！&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;猜猜这段代码的输出是什么？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import java.util.*;   
public class StaticTest{  
    public static void main(String[] args){  
        GT&amp;lt;Integer&amp;gt; gti = new GT&amp;lt;Integer&amp;gt;();  
        gti.var=1;  
        GT&amp;lt;String&amp;gt; gts = new GT&amp;lt;String&amp;gt;();  
        gts.var=2;  
        System.out.println(gti.var);  
    }  
}  
class GT&amp;lt;T&amp;gt;{  
    public static int var=0;  
    public void nothing(T x){}  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;答案是——2！由于经过类型擦除，所有的泛型类实例都关联到同一份字节码上，泛型类的所有静态变量是共享的。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;h4&gt;just remember&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;虚拟机中没有泛型，只有普通类和普通方法&lt;/li&gt;
&lt;li&gt;所有泛型类的类型参数在编译时都会被擦除&lt;/li&gt;
&lt;li&gt;创建泛型对象时请指明类型，让编译器尽早的做参数检查（Effective Java，第23条：请不要在新代码中使用原生态类型）&lt;/li&gt;
&lt;li&gt;不要忽略编译器的警告信息，那意味着潜在的&lt;code&gt;ClassCastException&lt;/code&gt;等着你&lt;/li&gt;
&lt;li&gt;不可协变(&lt;code&gt;List&amp;lt;Integer&amp;gt;&lt;/code&gt;不能赋值给&lt;code&gt;List&amp;lt;Number&amp;gt;&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    <item>
      <title>CountDownLatch与CyclicBarrier的使用和区别</title>
      <link>http://bakky.github.io/2013/工作/count.html</link>
      <pubDate>2013-07-06 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;`countdownlatch`&#34; href=&#34;#`countdownlatch`&#34;&gt;&lt;/a&gt;&lt;code&gt;CountDownLatch&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;&lt;br&gt;
应用场景：有一个任务A想要往下执行，但必须要等到其他的任务B、C执行完毕后才可以继续往下执行。&lt;/p&gt;

&lt;p&gt;使用方式：让任务A调用一个CountDownLatch对象的&lt;code&gt;await()&lt;/code&gt;方法，其他的任务执行完自己的任务后调用同一个CountDownLatch对象上的&lt;code&gt;countDown()&lt;/code&gt;方法，任务A将一直阻塞等待，直到这个CountDownLatch对象的计数值减到0为止。&lt;/p&gt;

&lt;p&gt;那么CountDownLatch内部是如何实现让这个任务一直阻塞等待一直到所有其它任务执行完的呢？&lt;/p&gt;

&lt;p&gt;粗略的想下，原理可能是初始化一个值为所有任务个数的原子计数器，当前线程一直循环等待，执行下去的条件是全局计数器值为0，其它任务线程执行完后全局计数器减1&lt;/p&gt;

&lt;p&gt;来看看其源码：&lt;code&gt;await()&lt;/code&gt;方法和&lt;code&gt;countDown()&lt;/code&gt;方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private final Sync sync;
public void await()
            throws InterruptedException {
    sync.acquireSharedInterruptibly(1);
}
public void countDown() {
    sync.releaseShared(1);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到主要依赖sync这个对象，Sync是个内部类，其继承于&lt;code&gt;AbstractQueuedSynchronizer&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private static final class Sync extends AbstractQueuedSynchronizer {
    int getCount() {
        return getState();
    }
    public int tryAcquireShared(int i) {
        return getState() != 0 ? -1 : 1;
    }
    public boolean tryReleaseShared(int i) {
        int j;
        int k;
        do {
            j = getState();
            if (j == 0)
                return false;
            k = j - 1;
        } while (!compareAndSetState(j, k));
        return k == 0;        
        private static final long serialVersionUID = -1739299674L;
        Sync(int i) {
            setState(i);
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;阻塞的逻辑都在&lt;code&gt;AbstractQueuedSynchronizer&lt;/code&gt;中，原理就是&lt;code&gt;await&lt;/code&gt;时比较一下&lt;code&gt;state&lt;/code&gt;（相当于count），如果满足了，则不阻塞（返回1），如果不满足，阻塞（返回-1）&lt;/p&gt;

&lt;p&gt;&lt;code&gt;AbstractQueuedSynchronizer&lt;/code&gt;没有用正常的&lt;code&gt;wait&lt;/code&gt;，&lt;code&gt;notifyAll&lt;/code&gt;，&lt;code&gt;lock&lt;/code&gt;的阻塞等方法，阻塞做法需要深入研究，详情可以参看&lt;a href=&#34;http://www.blogjava.net/xylz/archive/2010/07/09/325612.html&#34;&gt;这篇博客&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;tryReleaseShared&lt;/code&gt;中采用CAS的操作减少计数&lt;/p&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;`cyclicbarrier`&#34; href=&#34;#`cyclicbarrier`&#34;&gt;&lt;/a&gt;&lt;code&gt;CyclicBarrier&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;&lt;br&gt;
使用和原理解析详见&lt;a href=&#34;http://yhjhappy234.blog.163.com/blog/static/316328322013514112247947/&#34;&gt;这篇博客&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;区别&lt;/h3&gt;

&lt;p&gt;&lt;br&gt;
&lt;code&gt;CountDownLatch&lt;/code&gt; :&lt;/p&gt;

&lt;p&gt;一个线程(或者多个)， 等待另外N个线程完成某个事情之后才能执行。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;CyclicBarrier&lt;/code&gt; :&lt;/p&gt;

&lt;p&gt;N个线程相互等待，任何一个线程完成之前，所有的线程都必须等待。&lt;/p&gt;

&lt;p&gt;对于&lt;code&gt;CountDownLatch&lt;/code&gt;来说，重点是那个“一个线程”, 是它在等待， 而另外那N的线程在把“某个事情”做完之后可以继续等待，可以终止。而对于&lt;code&gt;CyclicBarrier&lt;/code&gt;来说，重点是那N个线程，他们之间任何一个没有完成，所有的线程都必须等待。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>输入流和输出流对接</title>
      <link>http://bakky.github.io/2013/工作/stream.html</link>
      <pubDate>2013-06-18 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;br /&gt;
基本原理：通过httpClient获取服务器端输入流InputStream,然后新建一个输出流，将输入流写入到输出流中&lt;/p&gt;

&lt;p&gt;使用场景：大量数据传输，list或数组装不下的情况&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      DefaultHttpClient client = new DefaultHttpClient();
      StringBuffer getString = new StringBuffer();
      HttpMethod method = null;
      HttpResponse response;
      JSONObject res = null;
      try {
            //url拼接

           //发起请求
           String url = getString.toString();
           HttpGet get = new HttpGet(url);
           response = client.execute(get);
           InputStream input = response.getEntity().getContent();
           File newFile = new File(tfsPath+&amp;quot;/&amp;quot;+new Date().getTime()+&amp;quot;_&amp;quot;+groupid+&amp;quot;.txt&amp;quot;);
           OutputStream output = new FileOutputStream(newFile);
           IOUtils.copy(input, output);
           return newFile.getPath();
      } catch (Exception e) {
           log.error(&amp;quot;error:&amp;quot;+getString+&amp;quot;[res:]&amp;quot;+res, e);
           return null;
      }finally{
           //释放连接
           if(method!=null)
                method.releaseConnection();
      }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将输入流写到输出流中使用了apache的IOUtils工具包，注意不要将服务端获取输入流单独提取方法，因为有个释放链接的过程，而对接的时候，连接是不能被关闭的。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>《effective java》笔记（更新中）</title>
      <link>http://bakky.github.io/2013/笔记/effective_java.html</link>
      <pubDate>2013-05-12 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4&gt;第21条：用函数对象表示策略&lt;/h4&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;java没有函数指针，可以用对象引用实现同样的功能&lt;/li&gt;
&lt;li&gt;如果一个类仅仅导出一个方法，那么这个实例就等同于一个指向该方法的指针（例如常见的排序比较器使用：Comparator）这样就可以在某一个对象的方法中执行其它对象。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Arrays.sort(stringArray,new Comparator&amp;lt;String&amp;gt;(){
     public int compare(String s1,String s2){
          return s1.length()-s2.length();
     }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每个比较器就是一个具体策略类，具体策略类往往使用匿名类声明（例如上面的例子），我们也可以声明一个普通的类实现Comparator接口。这个时候，我们可以考虑，因为用匿名类的话，每次执行调用的时候会生成一个新的对象实例，将这个函数对象存储在一个私有的静态final域中。&lt;/p&gt;

&lt;p&gt;如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class A{
     private static class Strlen implements Comparator&amp;lt;String&amp;gt;{
         public int compare(String s1,String s2){
          return s1.length()-s2.length();
          } 
     }
     public static final Comparator&amp;lt;String&amp;gt; STRING_LEN_COMPARE = new Strlen();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用就变成这样了：Arrays.sorts(stringArray,A.STRING_LEN_COMPARE),这样做的好处是：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;减少频繁创建对象的开销&lt;/li&gt;
&lt;li&gt;代码的可读性增加，重复利用，可以将A取一个有意义的域名称&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    <item>
      <title>《重构》笔记（更新中）</title>
      <link>http://bakky.github.io/2013/笔记/restruct.html</link>
      <pubDate>2013-05-08 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4&gt;第1章&lt;/h4&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在设计前期采用模式常常导致过度工程&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;开发业务代码时很容易面向过程编程&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;大方法差成小方法:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;所有行为拆成很多小行为，然后将合适的行为提炼到对象中
分拆出小方法（要避免过多参数的传递）
这样做可能还会带来代码量的增加
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;运用常用设计模式
    可以穿插看设计模式的书籍（对应设计模式）&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;第2章&lt;/h4&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;设计模式更像是重构的一种手段&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;重构就是在整理代码，让代码容易被理解喝修改&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;第6章&lt;/h4&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;优秀的代码组织和性能间的权衡&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    <item>
      <title>【转】关于java中的移位操作 - 红旗飘飘 - 博客频道 - CSDN.NET</title>
      <link>http://bakky.github.io/2013/工作/shift.html</link>
      <pubDate>2013-05-07 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;在Think in Java中有这么一段话“对char，byte或者short进行移位处理，那么在移位进行之前，它们会自动转换成一个int。只有右侧的5个低位才会有用。这样可防止我们在一个int数里移动不切实际的位数。若对一个long值进行处理，最后得到的结果也是long。此时只会用到右侧的6个低位，防止移动超过long值里现成的位数。”&lt;/p&gt;

&lt;p&gt;对上面那段话的理解是：移位操作符操作的运算对象是二进制的“位”，int类型是32位也就是2的5次幂 ！如果移32位以上，那么原来的数的信息会全部丢失，这样也就没有什么意义了！所以上面的“只有右侧的5个低位才会有用”说的是：移位操作符右端的那个数（化成二进制）的低5位才有用，即 X &amp;lt; &amp;lt;y; 是指y的低5位才有用，即不能大于32。 而对于long型也是同样的道理！&lt;/p&gt;

&lt;p&gt;因此，如果对一个int 型，进行移位，X &amp;lt; &amp;lt;y; 当y小于32时，移位后的结果一般都在我们的预料当中；而如果y大于32时，由于移位超出了int所能表示的范围，这时就先把y化成二进制数，然后取该二进制数右端的低5位，再把这5位化成十进制，此时的这个十进制就是要对X移动的位数。&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int a=140;   
a &amp;lt;&amp;lt; 34
System.out.println(Integer.toBinaryString(a &amp;lt;&amp;lt; 34));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面那两个语句的执行过程是：先把a化成二进制数：10001100
执行语句 a &amp;lt;&amp;lt; 34   对a左移32位时，先把 34化成二进制：100010，对该二进制数取右边5位，即00010，化成十进制数为2，所以实际上是对a左移两位。现在，地球人都会知道上面程序的输出结果是：1000110000&lt;/p&gt;
</description>
    </item>
    <item>
      <title>btrace用法补充</title>
      <link>http://bakky.github.io/2012/工作/btrace.html</link>
      <pubDate>2012-10-25 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;下载btrace并安装，将bin目录加入到path路径下
/builder 文件夹下为类文件 ，最好反编译下，因为写脚本的过程中只能用里面提供的api&lt;/p&gt;

&lt;p&gt;/samples 文件夹下为一些例子，各种标签和属性的用法可以用来参考&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://kenai.com/projects/btrace/pages/UserGuide&#34;&gt;btrace user guide&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;自己写了个统计在一段时间内方法执行时间的脚本：&lt;/p&gt;

&lt;p&gt;运行类：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import java. util. Random;
public class CaseObject {
      private static int sleepTotalTime= 0;    
      public boolean execute(int sleepTime) throws Exception {
          System. out. println( &amp;quot;sleep: &amp;quot;+sleepTime );
          sleepTotalTime+=sleepTime ;
          Thread. sleep(sleepTime );
          return true ;
      }
      public static void main(String [] args ) throws Exception {
           Random random =new Random();
           CaseObject object =new CaseObject();
           boolean result=true ;
           while(result ){
              result= object. execute( random. nextInt( 1000));
              Thread. sleep(1000 );
           }
     }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;btrace脚本：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import static com. sun. btrace. BTraceUtils.println ;
import static com. sun. btrace. BTraceUtils.str ;
import static com. sun. btrace. BTraceUtils.strcat ;
import static com. sun. btrace. BTraceUtils.timeMillis ;
import java. util. concurrent. atomic. AtomicInteger;
import com. sun. btrace. BTraceUtils;
import com. sun. btrace. annotations.BTrace ;
import com. sun. btrace. annotations.Kind ;
import com. sun. btrace. annotations.Location ;
import com. sun. btrace. annotations.OnMethod ;
import com. sun. btrace. annotations.OnTimer ;
import com. sun. btrace. annotations.Return ;
import com. sun. btrace. annotations.Self ;
import com. sun. btrace. annotations.TLS;
@BTrace
public class TraceMethodArgsAndReturn {
     private static Long total_time = 0L;
     private static AtomicInteger ato = BTraceUtils.newAtomicInteger (0 );    
     @TLS static long beginTime;
       @OnMethod(
          clazz= &amp;quot;CaseObject&amp;quot;,
          method= &amp;quot;execute&amp;quot;
       )
       public static void traceExecuteBegin(){
          beginTime=timeMillis ();
       }     
       @OnMethod(
          clazz= &amp;quot;CaseObject&amp;quot;,
          method= &amp;quot;execute&amp;quot;,
          location= @Location( Kind. RETURN)
       )
       public static void traceExecute(@Self CaseObject object,int sleepTime , @Return boolean result){
             println( strcat(&amp;quot;sleepTime is:&amp;quot; ,str(sleepTime)));
             BTraceUtils.getAndIncrement (ato);
             println( strcat(&amp;quot;第&amp;quot; ,strcat(str( BTraceUtils.get (ato)),&amp;quot;次执行&amp;quot;)));
             total_time += timeMillis()-beginTime ;
             println( strcat(strcat (&amp;quot;此次执行时间是:&amp;quot; ,str(timeMillis()- beginTime)),&amp;quot;ms&amp;quot; ));
     }   
       @OnTimer( 4000)
       public static void print(){
             println( strcat(&amp;quot;总共耗时：&amp;quot; ,str(total_time)));
             println( strcat(&amp;quot;总共执行&amp;quot; ,strcat(str( BTraceUtils.get (ato)),&amp;quot;次&amp;quot;)));
             float average = total_time.floatValue ()/BTraceUtils .get(ato);
             println( strcat(&amp;quot;平均执行时间:&amp;quot; ,str(average)));
       }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;记住，btrace脚本中只能用btrace提供的api，可能会有些不适应，所以需要反编译类文件查看用法。&lt;/p&gt;

&lt;p&gt;@TLS：标记为静态属性且为thread local&lt;/p&gt;
</description>
    </item>
    <item>
      <title>定义一种返回结果</title>
      <link>http://bakky.github.io/2012/工作/result.html</link>
      <pubDate>2012-10-11 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Result &amp;lt;T&amp;gt; {
     private boolean isSuccess ;
     private String message;
     private T result ;     
     /**
      * 创建一个只包含结果的result
      * @param isSuccess
      */
     public Result( boolean isSuccess){
            this.setSuccess (isSuccess );
     }     
     /**
      * 创建一个不带返回对象的result
      * @param isSuccess
      * @param message
      */
     public Result( boolean isSuccess, String message) {
            this.isSuccess = isSuccess;
            this.message = message;
     }     
     /**
      * 创建一个带返回对象的result
      * @param isSuccess
      * @param message
      */
     public Result( boolean isSuccess, String message, T result ) {
            this.isSuccess = isSuccess;
            this.message = message;
            this.result = result;
     }     
     /**
      * 返回一个成功的result，包含要返回的对象
      * @param result 结果对象
      */
     public Result( T result ){
            this.isSuccess =true;
            this.setResult (result );
     }
     /**
      * 创建一个失败的result，不包含返回对象
      * @param msg
      * @return
      */
     public static Result &amp;lt;Boolean &amp;gt; fail( String msg ){
            return new Result &amp;lt;Boolean &amp;gt;(false, msg);
     }   
     /**
      * 创建一个成功的result，不包含返回对象
      * @param msg
      * @return
      */
     public static Result &amp;lt;Boolean &amp;gt; succeed( String msg ){
            return new Result &amp;lt;Boolean &amp;gt;(true, msg);
     }     
     /**
      * 创建一个成功的result，不包含返回对象
      * @return
      */
     public static Result &amp;lt;Boolean &amp;gt; succeed(){
            return new Result &amp;lt;Boolean &amp;gt;(true);
     }     
     public boolean isSuccess () {
            return isSuccess ;
     }
     public Result&amp;lt; T&amp;gt; setSuccess(boolean isSuccess) {
            this.isSuccess = isSuccess;
            return this ;
     }
     public boolean isFailed (){
            return !isSuccess;
     }
     public String getMessage() {
            return message ;
     }
     public Result&amp;lt; T&amp;gt; setMessage(String message) {
            this.message = message;
            return this ;
     }
     public T getResult() {
            return result ;
     }
     public Result&amp;lt; T&amp;gt; setResult(T result) {
            this.result = result;
            return this ;
     }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    <item>
      <title>异常</title>
      <link>http://bakky.github.io/2012/工作/exception.html</link>
      <pubDate>2012-09-13 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;异常都派生于Throwable类的一个实例。&lt;/li&gt;
&lt;li&gt;Throwable下有两个子类分支：Error和Exception&lt;/li&gt;
&lt;li&gt;Error类描述java运行时系统的内部错误和资源耗尽，这种情况很少出现&lt;/li&gt;
&lt;li&gt;Exception下面又派生出两种异常分支：通常有程序导致的错误为RuntimeException，还有一类是IOException&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;java可以声明已检查异常，告诉编译器可能会发生什么样的错误。例如读文件方法可以&lt;code&gt;throw FileNotFoundException&lt;/code&gt;异常。已检查异常可以抛出多个。&lt;/p&gt;

&lt;p&gt;我们可以自定义一个派生于Exception或其子类的类&lt;/p&gt;

&lt;p&gt;再次抛出异常或异常链：&lt;/p&gt;

&lt;p&gt;这个可能大家在调用一些通用的模块的时候会发现它的异常信息是被包装了一层的，我们需要调用
对象的&lt;code&gt;getCause()&lt;/code&gt;方法才能得到异常信息。&lt;/p&gt;

&lt;p&gt;因为每个子系统可能会产生同样的异常，当我们的上层系统捕捉到这种异常时我们并不知道是哪个底层子系统抛出的。这个时候我们就可以将原是一场捕获后重新进行包装然后抛出代表这个子系统的异常，但是原始的异常信息也不会丢失。如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;try{
   access db
}catch(SQLException e){
   Throwable se = new MyAppException(&amp;quot;db error&amp;quot;);
    se.initCause(e);
    throw se;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    <item>
      <title>velocity渲染相关</title>
      <link>http://bakky.github.io/2012/工作/velocity.html</link>
      <pubDate>2012-09-12 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4&gt;velocity中对象field的渲染&lt;/h4&gt;

&lt;p&gt;&lt;br /&gt;
没看源码，但经过实验得知：&lt;/p&gt;

&lt;p&gt;如:&lt;code&gt;$!xxx.name&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;引擎渲染的时候先去调用xxx对象的&lt;code&gt;getName()&lt;/code&gt;方法，如果有这个方法，就直接返回&lt;code&gt;getName()&lt;/code&gt;的结果，
如果没有的话就回去调用xxx对象的&lt;code&gt;get(&amp;quot;name&amp;quot;)&lt;/code&gt;方法。&lt;/p&gt;

&lt;h4&gt;velocity判断为空和null&lt;/h4&gt;

&lt;p&gt;&lt;br /&gt;
&lt;code&gt;$!item.name.isNull()&lt;/code&gt;    是否为null&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$!item.name.isNotNull()&lt;/code&gt;  是否不为null&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;code&gt;#if(!$!item.name)&lt;/code&gt;    如果不为空&lt;/p&gt;

&lt;p&gt;&lt;code&gt;#if($!item.name)&lt;/code&gt;     如果为空&lt;/p&gt;
</description>
    </item>
    <item>
      <title>代理、动态代理</title>
      <link>http://bakky.github.io/2012/工作/proxy.html</link>
      <pubDate>2012-09-08 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;br /&gt;
代理很容易理解，我们平时想要去买火车票，票贩子和代售点都可以理解为代理。
代理的结构图也很简单，代理类中含有真实类的引用，客户端调用代理类的方法，实际上代理类会去调用真实类的真实方法。那么代理类的主要作用是什么呢？就是在执行真实类的真实方法时，额外做些事情。
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;那么动态代理呢，试想我们买火车票、买飞机票用代理了，如果我们想要买国外奶粉，我们可以用代购，那么这个时候我们又要创建一个代理，如果有很多这种情况而且我们额外要做的事情差不多，那么创建很多代理类就浪费了，动态代理就是解决这种情况的，允许运行时指定其为实现任意一种接口实现类的代理类。&lt;/p&gt;

&lt;p&gt;简单示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 *买票接口
 *
 */
 pubic interface Ticket{
    public void buyTicket();
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt; /**
 *真实买火车票类
 *
 */
 public class TrainTicket implements Ticket{
    @override
    public void buyTicket(){
        System.out.println(&amp;quot;买火车票&amp;quot;);
    }
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt; /**
 *真实买飞机票类
 *
 */
  public class PlainTicket implements Ticket{
    @override
    public void buyTicket(){
        System.out.println(&amp;quot;买飞机票&amp;quot;);
    }
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt; /**
 * 代理类
 *
 */
 public class TicketProxy implements InvocationHandler{
    private Object object=null;
    public TicketProxy(Object o){
        this.object = o;
    }   
    @override
    public Object invoke(Object arg0, Method arg1, Object[] arg2){
        Object result = null;
        try{
            System.out.println(&amp;quot;我是票贩子，买票一律收20元手续费&amp;quot;);
            result = arg1.invoke(object , arg2);
            System.out.println(&amp;quot;挣钱了，买酒喝去。。。&amp;quot;);
        }catch(Exception ex){
            System.exit(1);
        }
        return result;
    }
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt; public class Client{
    public static void main(String[] args){
        Ticket t = new PlainTicket();
        Ticket proxy = Proxy.newProxyInstance(t.getClass().getClassLoader() , t.getClass().getInterfaces() , new TicketProxy(t));
        proxy.buyTicket();
    }
 } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当需要增加买奶粉的时候，我们就不需要再增加一个代理类了，而只是需要创建相关买奶粉的接口，然后增加不同的实现类。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>String和StringUtil的判断为空区别</title>
      <link>http://bakky.github.io/2012/工作/empty.html</link>
      <pubDate>2012-08-29 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;br /&gt;
1.&lt;code&gt;str.isEmpty();return str==null||str.length()==0&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;str为null,则抛出空指针异常&lt;/p&gt;

&lt;p&gt;2.&lt;code&gt;StringUtils.isEmpty(str)&lt;/code&gt;返回true的条件是&lt;code&gt;str==null&lt;/code&gt; 或 &lt;code&gt;str.length()==0&lt;/code&gt;    null安全&lt;/p&gt;

&lt;p&gt;3.&lt;code&gt;StringUtils.isBlank(str)&lt;/code&gt;返回true的条件是&lt;code&gt;str==null&lt;/code&gt; 或 &lt;code&gt;str.length()==0&lt;/code&gt; 或 由空白符(whitespace) 构成&lt;/p&gt;

&lt;p&gt;4.&lt;code&gt;StringUtils.trimToNull(str)&lt;/code&gt;、&lt;code&gt;StringUtils.trimToEmpty(str)&lt;/code&gt;  去掉字符串两端的控制符(control characters, char &amp;lt;= 32) ,如果变为 null 或&amp;rdquo;&amp;ldquo;，则返回 null、&amp;rdquo;&amp;rdquo;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>数组的trimToSize方法</title>
      <link>http://bakky.github.io/2012/工作/shuzu.html</link>
      <pubDate>2012-08-23 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;br /&gt;
- 一旦能确认数组列表的大小不再发生变化，就可以调用&lt;code&gt;trimToSize&lt;/code&gt;方法。这个方
法将存储区域的大小调整为当前元素数量所需要的是存储空间数目。垃圾回收器将回收多余的存储空间。
- 一旦整理了数组列表的大小，添加新元素就需要花时间再次移动存储块，所以应该确认不会添加任何元素时，再调用&lt;code&gt;trimToSize&lt;/code&gt;.
- 代码洁癖的人适用&lt;/p&gt;
</description>
    </item>
    <item>
      <title>java自动装箱和拆箱</title>
      <link>http://bakky.github.io/2012/工作/box.html</link>
      <pubDate>2012-08-23 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;br /&gt;
如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;arrayList&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;Integer&amp;gt;();
list.add(3);    //1     自动打包（autowrapping）    
int n = list.get(i)  //2   拆包
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;步骤1，相当于list.add(new Integer(3))&lt;br /&gt;
步骤2，相当于nt n = list.get(i).intValue();&lt;/p&gt;

&lt;p&gt;对于封装类型的==比较 需要注意：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Integer a =100;
Integer b = 100;           
Integer c = 1000;
Integer d = 1000;           
int m = 1000;
int n = 1000;        
System. out.println(a==b);
System. out.println(c==d);           
System. out.println(m==n);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如上，返回结果分别为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;true
false
true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为什么会出现这样的结果呢？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;自动打包规范要求boolean、byte、char&amp;lt;=127,介于-128~127之间的short和int被包装到固定的对象中去&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;看源码，拿Integer举例:&lt;/p&gt;

&lt;p&gt;平常我们使用&lt;code&gt;Integer a = xxx；&lt;/code&gt;的时候，Integer类实际上是调用的是&lt;code&gt;public static Integer valueOf(int i)&lt;/code&gt;方法。这个方法是这样的:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static Integer valueOf(int i){
     final int offset = 128;
     if(i&amp;gt;= -128 &amp;amp;&amp;amp; i&amp;lt;= 127){
          return IntegerCache.cache[i+offset];
     }
     return new Integer(i); 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;IntegerCache.class:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static final Integer cache[] = new Integer[-(-128)+127+1];
static {
     for(int i=0;i&amp;lt;cache.length;i++){
          cache[i] = new Integer(i - 128);
     }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也就是说，当赋值在[-128, 127]区间时，Java是从同一个数据中取出同一个对象，即内存地址一样.可能[-128, 127]区间比较常用，这个区间内的Integer对象也作为静态变量初始化完成，这样直接返回对象可以提高效率。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>map的遍历和排序</title>
      <link>http://bakky.github.io/2012/工作/map.html</link>
      <pubDate>2012-08-10 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3&gt;map的遍历&lt;/h3&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;最常规的一种遍历方法：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;public static void work(Map&amp;lt;String, Student&amp;gt; map) {
    Collection&amp;lt;Student&amp;gt; c = map.values();
    Iterator it = c.iterator();
    for (; it.hasNext();) {
        System.out.println(it.next());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;利用keyset进行遍历，它的优点在于可以根据你所想要的key值得到你想要的 values，更具灵活性！！&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;public static void workByKeySet(Map&amp;lt;String, Student&amp;gt; map) {
    Set&amp;lt;String&amp;gt; key = map.keySet();
    for (Iterator it = key.iterator(); it.hasNext();) {
        String s = (String) it.next();
        System.out.println(map.get(s));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;比较复杂的一种遍历，它的灵活性太强了，想得到什么就能得到什么&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;public static void workByEntry(Map&amp;lt;String, Student&amp;gt; map) {
    Set&amp;lt;Map.Entry&amp;lt;String, Student&amp;gt;&amp;gt; set = map.entrySet();
    for (Iterator&amp;lt;Map.Entry&amp;lt;String, Student&amp;gt;&amp;gt; it = set.iterator(); it.hasNext();) {
        Map.Entry&amp;lt;String, Student&amp;gt; entry = (Map.Entry&amp;lt;String, Student&amp;gt;) it.next();
        System.out.println(entry.getKey() + &amp;quot;---&amp;gt;&amp;quot; + entry.getValue());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;map中的value排序&lt;/h3&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;中心思想：对key按value进行排序，然后放入linkedHashMap中,按要求定制Comparator&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;List&amp;lt;Long&amp;gt; keys = new ArrayList&amp;lt;Long&amp;gt;(map.keySet());           
Collections. sort(keys,new Comparator&amp;lt;Object &amp;gt;(){
    @Override
    public int compare( Object arg0, Object arg1) {
        return map.get(arg0).compareTo(map.get(arg1));
    }                
});    
Map&amp;lt;Long, String&amp;gt; catmap = new LinkedHashMap&amp;lt;Long,String&amp;gt;();  for(Long l : keys){           
    catmap.put(l, map.get(l));       
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
  </channel>
</rss>